// File: socketHandler.js
const { ObjectId } = require('mongodb');
const logger = require('./utils/logger');

// Map Ä‘á»ƒ lÆ°u tráº¡ng thÃ¡i online: userId (string) -> socketId
const onlineUsers = new Map();

// Map Ä‘á»ƒ track users Ä‘ang chá»‰nh sá»­a mindmap: mindmapId -> Set of {userId, username, socketId, cursor}
const mindmapRooms = new Map();

module.exports = (io, usersDb, chatDb) => {
    // Láº¥y cÃ¡c collection cáº§n thiáº¿t
    const messagesCollection = chatDb.collection('messages');
    const friendsCollection = usersDb.collection('friends'); // Collection Ä‘á»ƒ láº¥y danh sÃ¡ch báº¡n bÃ¨

    // === HÃ m helper láº¥y danh sÃ¡ch ID báº¡n bÃ¨ ===
    async function getFriendsList(userId) {
        if (!userId) return []; // Tráº£ vá» máº£ng rá»—ng náº¿u khÃ´ng cÃ³ userId
        try {
            const friendships = await friendsCollection.find({
                status: 'accepted', // Chá»‰ láº¥y báº¡n bÃ¨ Ä‘Ã£ cháº¥p nháº­n
                $or: [{ senderId: userId }, { receiverId: userId }] // TÃ¬m trong cáº£ hai trÆ°á»ng
            }).toArray();

            // Láº¥y ID cá»§a ngÆ°á»i báº¡n (khÃ´ng pháº£i userId hiá»‡n táº¡i)
            return friendships.map(f => {
                return f.senderId.equals(userId) ? f.receiverId : f.senderId;
            });
        } catch (error) {
            logger.error('Error fetching friends list', { userId: userId.toString(), error });
            return [];
        }
    }

    // === Xá»­ lÃ½ khi cÃ³ káº¿t ná»‘i má»›i ===
    io.on('connection', async (socket) => {
        console.log(`\nðŸ”Œ ========== NEW SOCKET CONNECTION ==========`);
        console.log(`ðŸ†” Socket ID: ${socket.id}`);
        console.log(`ðŸ“ Request URL: ${socket.request.url}`);
        console.log(`ðŸª Has session: ${!!socket.request.session}`);
        console.log(`ðŸ‘¤ Session user: ${socket.request.session?.user?._id || 'NOT FOUND'}`);
        
        let currentUserId = null; // Biáº¿n lÆ°u ObjectId cá»§a user cho socket nÃ y
        let currentUserIdString = null; // Biáº¿n lÆ°u string ID cá»§a user

        // --- 1. XÃ¡c thá»±c ngÆ°á»i dÃ¹ng qua session ---
        try {
            // Kiá»ƒm tra session vÃ  user._id tá»“n táº¡i
            if (socket.request.session?.user?._id) {
                currentUserId = new ObjectId(socket.request.session.user._id);
                currentUserIdString = currentUserId.toString();
                console.log(`âœ… User authenticated: ${currentUserIdString}`);
                console.log(`ðŸ‘¤ Username: ${socket.request.session.user.username}`);
                console.log(`========================================\n`);
            } else {
                console.error('âŒ Authentication failed: No session or user ID');
                console.log(`========================================\n`);
                throw new Error('Session or user ID missing.');
            }
        } catch (error) {
            logger.warn('Socket authentication error', { socketId: socket.id, error: error.message });
            socket.emit('chatError', 'Lá»—i xÃ¡c thá»±c. Vui lÃ²ng Ä‘Äƒng nháº­p láº¡i.');
            socket.disconnect(true);
            return;
        }

        // --- 2. Xá»¬ LÃ ASYNC OPERATIONS (ngay sau authentication) ---
        
        // LÆ°u tráº¡ng thÃ¡i online
        onlineUsers.set(currentUserIdString, socket.id);
        console.log(`ðŸŸ¢ User online: ${currentUserIdString}. Total online: ${onlineUsers.size}`);

        // Emit authenticated event Ä‘á»ƒ client biáº¿t cÃ³ thá»ƒ báº¯t Ä‘áº§u gá»­i events
        socket.emit('authenticated', { userId: currentUserIdString });

        // Láº¥y danh sÃ¡ch báº¡n bÃ¨ vÃ  thÃ´ng bÃ¡o (async, khÃ´ng block)
        const friendObjectIds = await getFriendsList(currentUserId);
        const friendIds = friendObjectIds.map(id => id.toString());

        friendIds.forEach(friendId => {
            const friendSocketId = onlineUsers.get(friendId);
            if (friendSocketId) {
                io.to(friendSocketId).emit('user online', { userId: currentUserIdString });
                console.log(`   ðŸ“¢ Notified friend ${friendId} (socket ${friendSocketId}) that ${currentUserIdString} is online.`);
            }
        });

        const onlineFriendIds = friendIds.filter(friendId => onlineUsers.has(friendId));
        socket.emit('friends status', { onlineFriendIds: onlineFriendIds });
        console.log(`   ðŸ“¡ Sent online status of ${onlineFriendIds.length} friends back to ${currentUserIdString}.`);

        // --- 3. ÄÄ‚NG KÃ Táº¤T Cáº¢ EVENT LISTENERS (sau async operations) ---
        
        // Join má»™t mindmap room
        socket.on('join-mindmap', async (data) => {
            console.log(`\nðŸŽ¨ ========== JOIN MINDMAP REQUEST ==========`);
            console.log(`ðŸ“© Received join-mindmap event from socket ${socket.id}`);
            console.log(`ðŸ‘¤ User ID: ${currentUserIdString}`);
            console.log(`ðŸ“¦ Data:`, data);
            
            if (!currentUserId || !data || !data.mindmapId) {
                console.error('âŒ Invalid join-mindmap data');
                logger.warn('Invalid join-mindmap data', { userId: currentUserIdString, data });
                return;
            }

            const { mindmapId } = data;
            const username = socket.request.session?.user?.username || currentUserIdString.slice(-4) || 'Anonymous';

            try {
                console.log(`ðŸšª Joining socket to room: mindmap:${mindmapId}`);
                
                // Join socket room
                await socket.join(`mindmap:${mindmapId}`);
                
                console.log(`âœ… Socket joined room successfully`);

                // ThÃªm user vÃ o mindmap room tracking
                if (!mindmapRooms.has(mindmapId)) {
                    console.log(`ðŸ“ Creating new room tracking for ${mindmapId}`);
                    mindmapRooms.set(mindmapId, new Map());
                }

                const roomUsers = mindmapRooms.get(mindmapId);
                roomUsers.set(currentUserIdString, {
                    userId: currentUserIdString,
                    username: username,
                    socketId: socket.id,
                    cursor: null,
                    joinedAt: new Date()
                });

                // Láº¥y danh sÃ¡ch users Ä‘ang online trong room
                const activeUsers = Array.from(roomUsers.values()).map(u => ({
                    userId: u.userId,
                    username: u.username,
                    cursor: u.cursor
                }));

                console.log(`ðŸŽ¨ User ${username} (${currentUserIdString}) joined mindmap ${mindmapId}`);
                console.log(`ðŸ“Š Total in room: ${activeUsers.length}`);
                console.log(`ðŸ‘¥ Users in room ${mindmapId}:`, Array.from(roomUsers.keys()));

                // Verify room membership with Socket.IO
                const socketsInRoom = Array.from(io.sockets.adapter.rooms.get(`mindmap:${mindmapId}`) || []);
                console.log(`ðŸ”Œ Socket IDs in room (Socket.IO):`, socketsInRoom);

                // âœ… XÃC NHáº¬N join thÃ nh cÃ´ng cho client (EMIT NGAY Láº¬P Tá»¨C)
                console.log(`ðŸ“¤ Sending join-mindmap-success to socket ${socket.id}`);
                socket.emit('join-mindmap-success', { mindmapId, activeUsers });
                console.log(`âœ… join-mindmap-success sent for ${mindmapId}`);
                console.log(`========================================\n`);

                // Gá»­i danh sÃ¡ch users cho user má»›i join
                socket.emit('mindmap-users-list', { users: activeUsers });

                // ThÃ´ng bÃ¡o cho cÃ¡c users khÃ¡c trong room
                socket.to(`mindmap:${mindmapId}`).emit('user-joined-mindmap', {
                    userId: currentUserIdString,
                    username: username
                });

            } catch (error) {
                console.error('âŒ Error joining mindmap:', error);
                logger.error('Error joining mindmap', { userId: currentUserIdString, mindmapId, error });
                socket.emit('mindmap-error', 'KhÃ´ng thá»ƒ join mindmap.');
            }
        });

        // Leave mindmap room
        socket.on('leave-mindmap', (data) => {
            if (!data || !data.mindmapId) return;
            const { mindmapId } = data;

            socket.leave(`mindmap:${mindmapId}`);

            if (mindmapRooms.has(mindmapId)) {
                const roomUsers = mindmapRooms.get(mindmapId);
                roomUsers.delete(currentUserIdString);

                if (roomUsers.size === 0) {
                    mindmapRooms.delete(mindmapId);
                }

                console.log(`ðŸšª User ${currentUserIdString} left mindmap ${mindmapId}`);

                // ThÃ´ng bÃ¡o cho users khÃ¡c
                socket.to(`mindmap:${mindmapId}`).emit('user-left-mindmap', {
                    userId: currentUserIdString
                });
            }
        });

        // Broadcast mindmap changes (nodes/edges update)
        socket.on('mindmap-change', (data) => {
            if (!data || !data.mindmapId) return;

            const { mindmapId, changes, changeType } = data;

            // Check users in room
            const roomUsers = mindmapRooms.get(mindmapId);
            const usersInRoom = roomUsers ? Array.from(roomUsers.keys()) : [];
            console.log(`\nðŸ“ ========== MINDMAP CHANGE ==========`);
            console.log(`ðŸ‘¤ Broadcasting user: ${currentUserIdString} (socket ${socket.id})`);
            console.log(`ðŸŽ¨ Mindmap room: mindmap:${mindmapId}`);
            console.log(`ðŸ‘¥ Total users in room: ${usersInRoom.length}`);
            console.log(`ðŸ‘¥ User IDs:`, usersInRoom);
            
            // Get socket IDs in the room
            const socketsInRoom = Array.from(io.sockets.adapter.rooms.get(`mindmap:${mindmapId}`) || []);
            console.log(`ðŸ”Œ Socket IDs in room:`, socketsInRoom);
            console.log(`ðŸ”Œ Current socket:`, socket.id);
            console.log(`ðŸ“Š Change type:`, changeType);

            // Broadcast Ä‘áº¿n táº¥t cáº£ users khÃ¡c trong room (khÃ´ng gá»­i láº¡i cho chÃ­nh mÃ¬nh)
            const broadcastData = {
                userId: currentUserIdString,
                changes: changes,
                changeType: changeType,
                timestamp: Date.now()
            };
            
            console.log(`ðŸ“¤ Emitting mindmap-update to room (excluding self)`);
            socket.to(`mindmap:${mindmapId}`).emit('mindmap-update', broadcastData);
            
            console.log(`âœ… Broadcast completed. Should reach ${socketsInRoom.length - 1} other sockets`);
            console.log(`========================================\n`);
        });

        // Update cursor position
        socket.on('cursor-move', (data) => {
            if (!data || !data.mindmapId) return;

            const { mindmapId, cursor } = data; // cursor: { x, y }

            // Cáº­p nháº­t cursor trong tracking
            if (mindmapRooms.has(mindmapId)) {
                const roomUsers = mindmapRooms.get(mindmapId);
                const userInfo = roomUsers.get(currentUserIdString);
                if (userInfo) {
                    userInfo.cursor = cursor;
                }
            }

            // Broadcast cursor position
            socket.to(`mindmap:${mindmapId}`).emit('cursor-update', {
                userId: currentUserIdString,
                username: socket.request.session?.user?.username || 'Anonymous',
                cursor: cursor
            });
        });

        // Node selection (Ä‘á»ƒ hiá»ƒn thá»‹ ai Ä‘ang select node nÃ o)
        socket.on('node-select', (data) => {
            if (!data || !data.mindmapId) return;

            const { mindmapId, nodeIds } = data; // nodeIds: array of selected node IDs

            socket.to(`mindmap:${mindmapId}`).emit('node-selection-update', {
                userId: currentUserIdString,
                username: socket.request.session?.user?.username || 'Anonymous',
                nodeIds: nodeIds
            });
        });

        // Chat event listeners
        socket.on('getChatHistory', async (data) => {
            if (!currentUserId || !data || !data.receiverId) return;
            try {
                const receiverId = new ObjectId(data.receiverId);
                
                // CRITICAL: Kiá»ƒm tra xem hai ngÆ°á»i cÃ³ pháº£i báº¡n bÃ¨ khÃ´ng
                const isFriend = await friendsCollection.findOne({
                    status: 'accepted',
                    $or: [
                        { senderId: currentUserId, receiverId: receiverId },
                        { senderId: receiverId, receiverId: currentUserId }
                    ]
                });

                if (!isFriend) {
                    logger.warn('Unauthorized chat history access', { 
                        requesterId: currentUserIdString, 
                        targetId: data.receiverId 
                    });
                    socket.emit('chatError', 'Báº¡n chá»‰ cÃ³ thá»ƒ xem tin nháº¯n vá»›i báº¡n bÃ¨.');
                    return;
                }

                const messages = await messagesCollection.find({
                    $or: [
                        { senderId: currentUserId, receiverId: receiverId },
                        { senderId: receiverId, receiverId: currentUserId }
                    ]
                }).sort({ createdAt: 1 }).toArray();

                socket.emit('chatHistory', {
                    receiverId: data.receiverId,
                    messages: messages,
                    currentUserId: currentUserIdString
                });
            } catch (error) {
                logger.error('Error fetching chat history', { 
                    userId: currentUserIdString, 
                    receiverId: data.receiverId, 
                    error 
                });
                socket.emit('chatError', 'KhÃ´ng thá»ƒ táº£i lá»‹ch sá»­ tin nháº¯n.');
            }
        });

        socket.on('sendMessage', async (data) => {
            if (!currentUserId || !data || !data.receiverId || !data.content) {
                logger.warn('Invalid sendMessage data', { userId: currentUserIdString, data });
                return;
            }
            try {
                const receiverId = new ObjectId(data.receiverId);
                const message = {
                    senderId: currentUserId,
                    receiverId: receiverId,
                    content: data.content,
                    createdAt: new Date()
                };
                const result = await messagesCollection.insertOne(message);

                socket.emit('messageSent', { ...message, senderId: currentUserIdString, receiverId: data.receiverId });

                const receiverSocketId = onlineUsers.get(data.receiverId);
                if (receiverSocketId) {
                    io.to(receiverSocketId).emit('receiveMessage', { ...message, senderId: currentUserIdString, receiverId: data.receiverId });
                }
            } catch (error) {
                logger.error('Error sending message', { 
                    senderId: currentUserIdString, 
                    receiverId: data.receiverId, 
                    error 
                });
                socket.emit('chatError', 'Gá»­i tin nháº¯n tháº¥t báº¡i.');
            }
        });

        socket.on('typingStart', (data) => {
            if (!currentUserId || !data || !data.receiverId) return;
            const receiverSocketId = onlineUsers.get(data.receiverId);
            if (receiverSocketId) {
                io.to(receiverSocketId).emit('typing', { userId: currentUserIdString, isTyping: true });
            }
        });

        socket.on('typingStop', (data) => {
             if (!currentUserId || !data || !data.receiverId) return;
            const receiverSocketId = onlineUsers.get(data.receiverId);
            if (receiverSocketId) {
                io.to(receiverSocketId).emit('typing', { userId: currentUserIdString, isTyping: false });
            }
        });

        socket.on('disconnect', async (reason) => {
            console.log(`ðŸ”Œ User disconnected: ${socket.id}. UserID: ${currentUserIdString}. Reason: ${reason}`);
            if (currentUserIdString) {
                mindmapRooms.forEach((roomUsers, mindmapId) => {
                    if (roomUsers.has(currentUserIdString)) {
                        roomUsers.delete(currentUserIdString);
                        
                        io.to(`mindmap:${mindmapId}`).emit('user-left-mindmap', {
                            userId: currentUserIdString
                        });

                        console.log(`ðŸšª User ${currentUserIdString} auto-left mindmap ${mindmapId} on disconnect`);

                        if (roomUsers.size === 0) {
                            mindmapRooms.delete(mindmapId);
                        }
                    }
                });

                onlineUsers.delete(currentUserIdString);
                console.log(`ðŸ”´ User offline: ${currentUserIdString}. Total online: ${onlineUsers.size}`);

                const friendObjectIdsOnDisconnect = await getFriendsList(currentUserId);
                const friendIdsOnDisconnect = friendObjectIdsOnDisconnect.map(id => id.toString());

                friendIdsOnDisconnect.forEach(friendId => {
                    const friendSocketId = onlineUsers.get(friendId);
                    if (friendSocketId) {
                        io.to(friendSocketId).emit('user offline', { userId: currentUserIdString });
                        console.log(`   ðŸ“¢ Notified friend ${friendId} (socket ${friendSocketId}) that ${currentUserIdString} is offline.`);
                    }
                });
            }
            currentUserId = null;
            currentUserIdString = null;
        });

        // --- 3. Xá»¬ LÃ ASYNC OPERATIONS (sau khi Ä‘Ã£ Ä‘Äƒng kÃ½ listeners) ---
        
        // LÆ°u tráº¡ng thÃ¡i online
        onlineUsers.set(currentUserIdString, socket.id);
        console.log(`ðŸŸ¢ User online: ${currentUserIdString}. Total online: ${onlineUsers.size}`);

        // Emit authenticated event Ä‘á»ƒ client biáº¿t cÃ³ thá»ƒ báº¯t Ä‘áº§u gá»­i events
        socket.emit('authenticated', { userId: currentUserIdString });

        // Láº¥y danh sÃ¡ch báº¡n bÃ¨ vÃ  thÃ´ng bÃ¡o (async, khÃ´ng block)
        const friendObjectIds = await getFriendsList(currentUserId);
        const friendIds = friendObjectIds.map(id => id.toString());

        friendIds.forEach(friendId => {
            const friendSocketId = onlineUsers.get(friendId);
            if (friendSocketId) {
                io.to(friendSocketId).emit('user online', { userId: currentUserIdString });
                console.log(`   ðŸ“¢ Notified friend ${friendId} (socket ${friendSocketId}) that ${currentUserIdString} is online.`);
            }
        });

        const onlineFriendIds = friendIds.filter(friendId => onlineUsers.has(friendId));
        socket.emit('friends status', { onlineFriendIds: onlineFriendIds });
        console.log(`   ðŸ“¡ Sent online status of ${onlineFriendIds.length} friends back to ${currentUserIdString}.`);
            console.log(`\nðŸŽ¨ ========== JOIN MINDMAP REQUEST ==========`);
            console.log(`ðŸ“© Received join-mindmap event from socket ${socket.id}`);
            console.log(`ðŸ‘¤ User ID: ${currentUserIdString}`);
            console.log(`ðŸ“¦ Data:`, data);
            
            if (!currentUserId || !data || !data.mindmapId) {
                console.error('âŒ Invalid join-mindmap data');
                logger.warn('Invalid join-mindmap data', { userId: currentUserIdString, data });
                return;
            }

            const { mindmapId } = data;
            const username = socket.request.session?.user?.username || currentUserIdString.slice(-4) || 'Anonymous';

            try {
                console.log(`ðŸšª Joining socket to room: mindmap:${mindmapId}`);
                
                // Join socket room
                await socket.join(`mindmap:${mindmapId}`);
                
                console.log(`âœ… Socket joined room successfully`);

                // ThÃªm user vÃ o mindmap room tracking
                if (!mindmapRooms.has(mindmapId)) {
                    console.log(`ðŸ“ Creating new room tracking for ${mindmapId}`);
                    mindmapRooms.set(mindmapId, new Map());
                }

                const roomUsers = mindmapRooms.get(mindmapId);
                roomUsers.set(currentUserIdString, {
                    userId: currentUserIdString,
                    username: username,
                    socketId: socket.id,
                    cursor: null,
                    joinedAt: new Date()
                });

                // Láº¥y danh sÃ¡ch users Ä‘ang online trong room
                const activeUsers = Array.from(roomUsers.values()).map(u => ({
                    userId: u.userId,
                    username: u.username,
                    cursor: u.cursor
                }));

                console.log(`ðŸŽ¨ User ${username} (${currentUserIdString}) joined mindmap ${mindmapId}`);
                console.log(`ðŸ“Š Total in room: ${activeUsers.length}`);
                console.log(`ðŸ‘¥ Users in room ${mindmapId}:`, Array.from(roomUsers.keys()));

                // Verify room membership with Socket.IO
                const socketsInRoom = Array.from(io.sockets.adapter.rooms.get(`mindmap:${mindmapId}`) || []);
                console.log(`ðŸ”Œ Socket IDs in room (Socket.IO):`, socketsInRoom);

                // âœ… XÃC NHáº¬N join thÃ nh cÃ´ng cho client (EMIT NGAY Láº¬P Tá»¨C)
                console.log(`ðŸ“¤ Sending join-mindmap-success to socket ${socket.id}`);
                socket.emit('join-mindmap-success', { mindmapId, activeUsers });
                console.log(`âœ… join-mindmap-success sent for ${mindmapId}`);
                console.log(`========================================\n`);

                // Gá»­i danh sÃ¡ch users cho user má»›i join
                socket.emit('mindmap-users-list', { users: activeUsers });

                // ThÃ´ng bÃ¡o cho cÃ¡c users khÃ¡c trong room
                socket.to(`mindmap:${mindmapId}`).emit('user-joined-mindmap', {
                    userId: currentUserIdString,
                    username: username
                });

            } catch (error) {
                console.error('âŒ Error joining mindmap:', error);
                logger.error('Error joining mindmap', { userId: currentUserIdString, mindmapId, error });
                socket.emit('mindmap-error', 'KhÃ´ng thá»ƒ join mindmap.');
            }
        });

        // Leave mindmap room
        socket.on('leave-mindmap', (data) => {
            if (!data || !data.mindmapId) return;
            const { mindmapId } = data;

            socket.leave(`mindmap:${mindmapId}`);

            if (mindmapRooms.has(mindmapId)) {
                const roomUsers = mindmapRooms.get(mindmapId);
                roomUsers.delete(currentUserIdString);

                if (roomUsers.size === 0) {
                    mindmapRooms.delete(mindmapId);
                }

                console.log(`ðŸšª User ${currentUserIdString} left mindmap ${mindmapId}`);

                // ThÃ´ng bÃ¡o cho users khÃ¡c
                socket.to(`mindmap:${mindmapId}`).emit('user-left-mindmap', {
                    userId: currentUserIdString
                });
            }
        });

        // Broadcast mindmap changes (nodes/edges update)
        socket.on('mindmap-change', (data) => {
            if (!data || !data.mindmapId) return;

            const { mindmapId, changes, changeType } = data;

            // Check users in room
            const roomUsers = mindmapRooms.get(mindmapId);
            const usersInRoom = roomUsers ? Array.from(roomUsers.keys()) : [];
            console.log(`\nðŸ“ ========== MINDMAP CHANGE ==========`);
            console.log(`ðŸ‘¤ Broadcasting user: ${currentUserIdString} (socket ${socket.id})`);
            console.log(`ðŸŽ¨ Mindmap room: mindmap:${mindmapId}`);
            console.log(`ðŸ‘¥ Total users in room: ${usersInRoom.length}`);
            console.log(`ðŸ‘¥ User IDs:`, usersInRoom);
            
            // Get socket IDs in the room
            const socketsInRoom = Array.from(io.sockets.adapter.rooms.get(`mindmap:${mindmapId}`) || []);
            console.log(`ðŸ”Œ Socket IDs in room:`, socketsInRoom);
            console.log(`ðŸ”Œ Current socket:`, socket.id);
            console.log(`ðŸ“Š Change type:`, changeType);

            // Broadcast Ä‘áº¿n táº¥t cáº£ users khÃ¡c trong room (khÃ´ng gá»­i láº¡i cho chÃ­nh mÃ¬nh)
            const broadcastData = {
                userId: currentUserIdString,
                changes: changes,
                changeType: changeType,
                timestamp: Date.now()
            };
            
            console.log(`ðŸ“¤ Emitting mindmap-update to room (excluding self)`);
            socket.to(`mindmap:${mindmapId}`).emit('mindmap-update', broadcastData);
            
            console.log(`âœ… Broadcast completed. Should reach ${socketsInRoom.length - 1} other sockets`);
            console.log(`========================================\n`);
        });

        socket.on('disconnect', async (reason) => {
            console.log(`ðŸ”Œ User disconnected: ${socket.id}. UserID: ${currentUserIdString}. Reason: ${reason}`);
            if (currentUserIdString) {
                mindmapRooms.forEach((roomUsers, mindmapId) => {
                    if (roomUsers.has(currentUserIdString)) {
                        roomUsers.delete(currentUserIdString);
                        
                        io.to(`mindmap:${mindmapId}`).emit('user-left-mindmap', {
                            userId: currentUserIdString
                        });

                        console.log(`ðŸšª User ${currentUserIdString} auto-left mindmap ${mindmapId} on disconnect`);

                        if (roomUsers.size === 0) {
                            mindmapRooms.delete(mindmapId);
                        }
                    }
                });

                onlineUsers.delete(currentUserIdString);
                console.log(`ðŸ”´ User offline: ${currentUserIdString}. Total online: ${onlineUsers.size}`);

                const friendObjectIdsOnDisconnect = await getFriendsList(currentUserId);
                const friendIdsOnDisconnect = friendObjectIdsOnDisconnect.map(id => id.toString());

                friendIdsOnDisconnect.forEach(friendId => {
                    const friendSocketId = onlineUsers.get(friendId);
                    if (friendSocketId) {
                        io.to(friendSocketId).emit('user offline', { userId: currentUserIdString });
                        console.log(`   ðŸ“¢ Notified friend ${friendId} (socket ${friendSocketId}) that ${currentUserIdString} is offline.`);
                    }
                });
            }
            currentUserId = null;
            currentUserIdString = null;
        });

    }); // Káº¿t thÃºc io.on('connection')
}; // Káº¿t thÃºc module.exports